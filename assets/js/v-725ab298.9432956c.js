"use strict";(self.webpackChunknew=self.webpackChunknew||[]).push([[288],{2902:(n,s,a)=>{a.r(s),a.d(s,{data:()=>p});const p={key:"v-725ab298",path:"/notes/JS%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87.html",title:"JS变量提升和函数提升",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"JS变量提升和函数提升",slug:"js变量提升和函数提升-1",children:[]},{level:2,title:"匿名函数声明",slug:"匿名函数声明",children:[]}],filePathRelative:"notes/JS变量提升和函数提升.md",git:{updatedTime:1634807468e3,contributors:[{name:"pangqingbo",email:"2362698454@qq.com",commits:1}]}}},9315:(n,s,a)=>{a.r(s),a.d(s,{default:()=>t});const p=(0,a(6252).uE)('<h1 id="js变量提升和函数提升" tabindex="-1"><a class="header-anchor" href="#js变量提升和函数提升" aria-hidden="true">#</a> JS变量提升和函数提升</h1><h2 id="js变量提升和函数提升-1" tabindex="-1"><a class="header-anchor" href="#js变量提升和函数提升-1" aria-hidden="true">#</a> JS变量提升和函数提升</h2><p>正常情况下，我们会选择使用“先声明，后调用”的方式去使用变量，但假如反过来，我们“先调用，后声明”，会发生什么呢？</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// undefined</span>\n<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 3</span>\n\n<span class="token comment">// 上面代码等价于下面的代码</span>\n<span class="token keyword">var</span> a\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// undefined</span>\na <span class="token operator">=</span> <span class="token number">3</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 3</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>正如上面的例子一样，变量在真正执行到赋值语句前，我们就已经可以使用到此变量，不过初始值为undefined，而不是预期的报错语句。这就叫做<strong>变量提升</strong>。</p><p>而对于函数的声明和使用，也会出现类似的情况：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token comment">// function foo() {}</span>\nfoo <span class="token operator">=</span> <span class="token number">3</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token comment">// 3</span>\n<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token comment">// 相当于下面的代码</span>\n<span class="token keyword">var</span> foo\n<span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token comment">// function foo() {}</span>\nfoo <span class="token operator">=</span> <span class="token number">3</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token comment">// 3</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在执行声明函数语句之前，我们已经可以调用函数方法并正确输出。这便是<strong>函数提升</strong>。</p><p>需要注意的是，函数声明的处理优先级要高于变量声明（意味着函数会“提升”到更靠前的位置）</p><h2 id="匿名函数声明" tabindex="-1"><a class="header-anchor" href="#匿名函数声明" aria-hidden="true">#</a> 匿名函数声明</h2><p>基于变量声明和函数声明之间的区别，在实际应用中，使用匿名函数的方式执行声明更不容易产生奇怪的 Bug：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Uncaught TypeError: sayHi is not a function</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sayHi<span class="token punctuation">)</span> <span class="token comment">// undefined</span>\n<span class="token keyword">var</span> <span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Hi there!&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Hi there!</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>使用匿名函数声明时，sayHi 声明发生变量提升，但赋值为 undefined，因此执行 sayHi() 时会报错 Uncaught TypeError: sayHi is not a function。随后执行完赋值语句后，才成为一个可以执行的函数变量。</p>',13),e={},t=(0,a(3744).Z)(e,[["render",function(n,s){return p}]])},3744:(n,s)=>{s.Z=(n,s)=>{const a=n.__vccOpts||n;for(const[n,p]of s)a[n]=p;return a}}}]);